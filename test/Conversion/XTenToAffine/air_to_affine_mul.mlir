// RUN: aten-opt %s --xten-to-affine -cse | FileCheck %s
// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py


// CHECK-LABEL:   func @task(
// CHECK-SAME:               %[[VAL_0:.*]]: tensor<2x3x4x5xi32>,
// CHECK-SAME:               %[[VAL_1:.*]]: tensor<2x3x4x5xi32>) -> tensor<2x3x4x5xi32> {
// CHECK:           %[[VAL_2:.*]] = memref.alloc() : memref<2x3x4x5xi32>
// CHECK:           %[[VAL_3:.*]] = memref.buffer_cast %[[VAL_0]] : memref<2x3x4x5xi32>
// CHECK:           %[[VAL_4:.*]] = memref.buffer_cast %[[VAL_1]] : memref<2x3x4x5xi32>
// CHECK:           affine.for %[[VAL_5:.*]] = 0 to 2 {
// CHECK:             affine.for %[[VAL_6:.*]] = 0 to 3 {
// CHECK:               affine.for %[[VAL_7:.*]] = 0 to 4 {
// CHECK:                 affine.for %[[VAL_8:.*]] = 0 to 5 {
// CHECK:                   %[[VAL_9:.*]] = affine.load %[[VAL_3]]{{\[}}%[[VAL_5]], %[[VAL_6]], %[[VAL_7]], %[[VAL_8]]] : memref<2x3x4x5xi32>
// CHECK:                   %[[VAL_10:.*]] = affine.load %[[VAL_4]]{{\[}}%[[VAL_5]], %[[VAL_6]], %[[VAL_7]], %[[VAL_8]]] : memref<2x3x4x5xi32>
// CHECK:                   %[[VAL_11:.*]] = muli %[[VAL_9]], %[[VAL_10]] : i32
// CHECK:                   affine.store %[[VAL_11]], %[[VAL_2]]{{\[}}%[[VAL_5]], %[[VAL_6]], %[[VAL_7]], %[[VAL_8]]] : memref<2x3x4x5xi32>
// CHECK:                 }
// CHECK:               }
// CHECK:             }
// CHECK:           } {affine_opt_label = "{{.*}}"}
// CHECK:           %[[VAL_12:.*]] = memref.tensor_load %[[VAL_2]] : memref<2x3x4x5xi32>
// CHECK:           return %[[VAL_12]] : tensor<2x3x4x5xi32>
// CHECK:         }
module  {
  func @task(%arg0: tensor<2x3x4x5xi32>, %arg1: tensor<2x3x4x5xi32>) -> tensor<2x3x4x5xi32> {
    %0 = "xten.mul"(%arg0, %arg1) : (tensor<2x3x4x5xi32>, tensor<2x3x4x5xi32>) -> tensor<2x3x4x5xi32>
    return %0 : tensor<2x3x4x5xi32>
  }
}