//===- aten_batchnorm.mlir -------------------------------------*- MLIR -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2019 Xilinx Inc.
//
//===----------------------------------------------------------------------===//

// RUN: aten-opt %s -aten-op-report | FileCheck %s
//   CHECK-LABEL:       "{{.*}}": {
//   CHECK-NEXT:          "activation_in": 103320,
//   CHECK-NEXT:          "activation_out": 103320,
//   CHECK-NEXT:          "ops:*": 310206,
//   CHECK-NEXT:          "ops:+": 413280,
//   CHECK-NEXT:          "ops:-": 123,
//   CHECK-NEXT:          "ops:/": 123,
//   CHECK-NEXT:          "ops:sqrt": 123,
//   CHECK-NEXT:          "parameters_in": 246,
//   CHECK-NEXT:          "reads": 103566,
//   CHECK-NEXT:          "writes": 103320

// RUN: aten-opt %s -aten-lowering | FileCheck %s --check-prefix=ATEN
// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
// ATEN:       module {

// ATEN-LABEL:   func @graph(
// ATEN-SAME:                %[[VAL_0:.*]]: memref<42x123x4x5xf32>, %[[VAL_1:.*]]: memref<123xf32>, %[[VAL_2:.*]]: memref<123xf32>, %[[VAL_3:.*]]: memref<123xf32>, %[[VAL_4:.*]]: memref<123xf32>) -> memref<42x123x4x5xf32> {
// ATEN:           %[[VAL_6:.*]] = constant true
// ATEN:           %[[VAL_7:.*]] = constant 1.000000e-01 : f32
// ATEN:           %[[VAL_8:.*]] = constant 9.99999974E-6 : f32
// ATEN:           %[[VAL_10:.*]]:3 = call @batch_norm_AtenAcapOp_M42x123x4x5xF32_M123xF32_M123xF32_M42x123x4x5xF32_M123xF32_M123xF32_M123xF32_M123xF32_I1_F32_F32_I1(%[[VAL_0]], %[[VAL_1]], %[[VAL_2]], %[[VAL_3]], %[[VAL_4]], %[[VAL_6]], %[[VAL_7]], %[[VAL_8]], %[[VAL_6]]) : (memref<42x123x4x5xf32>, memref<123xf32>, memref<123xf32>, memref<123xf32>, memref<123xf32>, i1, f32, f32, i1) -> (memref<42x123x4x5xf32>, memref<123xf32>, memref<123xf32>)
// ATEN:           return %[[VAL_10]]#0 : memref<42x123x4x5xf32>
// ATEN:         }

// ATEN-LABEL:   func private @batch_norm_AtenAcapOp_M42x123x4x5xF32_M123xF32_M123xF32_M42x123x4x5xF32_M123xF32_M123xF32_M123xF32_M123xF32_I1_F32_F32_I1(memref<42x123x4x5xf32>, memref<123xf32>, memref<123xf32>, memref<123xf32>, memref<123xf32>, i1, f32, f32, i1) -> (memref<42x123x4x5xf32>, memref<123xf32>, memref<123xf32>)
// ATEN:       }

module {
  func @graph(%arg0: tensor<42x123x4x5xf32>, %arg1: tensor<123xf32>, %arg2: tensor<123xf32>, %arg3: tensor<123xf32>, %arg4: tensor<123xf32>) -> tensor<42x123x4x5xf32> {
    %true = constant true
    %cst = constant 1.000000e-01 : f32
    %cst_0 = constant 9.99999974E-6 : f32
    %output, %save_mean, %save_invstd = "aten.batch_norm"(%arg0, %arg1, %arg2, %arg3, %arg4, %true, %cst, %cst_0, %true) : (tensor<42x123x4x5xf32>, tensor<123xf32>, tensor<123xf32>, tensor<123xf32>, tensor<123xf32>, i1, f32, f32, i1) -> (tensor<42x123x4x5xf32>, tensor<123xf32>, tensor<123xf32>)
    return %output : tensor<42x123x4x5xf32>
  }
}
