//===- aten_conv2d_3x3.mlir ------------------------------------*- MLIR -*-===//
//
// This file is licensed under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// (c) Copyright 2019 Xilinx Inc.
//
//===----------------------------------------------------------------------===//

// RUN: aten-opt %s -aten-op-report | FileCheck %s
//   CHECK-LABEL:   "{{.*}}": {
//   CHECK-NEXT:     "activation_in": 32768,
//   CHECK-NEXT:     "activation_out": 65536,
//   CHECK-NEXT:     "ops:+": 65536,
//   CHECK-NEXT:     "ops:MAC": 1179648,
//   CHECK-NEXT:     "parameters_in": 304,
//   CHECK-NEXT:     "reads": 33072,
//   CHECK-NEXT:     "writes": 65536

// RUN: aten-opt -cse %s -aten-lowering -cse -cse | FileCheck %s --check-prefix=ATEN
// NOTE: Assertions have been autogenerated by utils/generate-test-checks.py
// ATEN:       module {

// ATEN-LABEL:   func @graph(
// ATEN-SAME:                %[[VAL_0:.*]]: memref<1x2x128x128xf32>, %[[VAL_1:.*]]: memref<16x2x3x3xf32>, %[[VAL_2:.*]]: memref<16xf32>) -> memref<1x16x64x64xf32> {
// ATEN:           %[[VAL_3:.*]] = constant 2 : i32
// ATEN:           %[[VAL_4:.*]] = constant 1 : i32
// ATEN:           %[[VAL_5:.*]] = constant 3 : i32
// ATEN:           %[[VAL_6:.*]] = call @conv2d_AtenAcapOp_M1x16x64x64xF32_M1x2x128x128xF32_M16x2x3x3xF32_M16xF32_I32_I32_I32(%[[VAL_0]], %[[VAL_1]], %[[VAL_2]], %[[VAL_3]], %[[VAL_4]], %[[VAL_5]]) : (memref<1x2x128x128xf32>, memref<16x2x3x3xf32>, memref<16xf32>, i32, i32, i32) -> memref<1x16x64x64xf32>
// ATEN:           return %[[VAL_6]] : memref<1x16x64x64xf32>
// ATEN:         }

// ATEN-LABEL:   func private @conv2d_AtenAcapOp_M1x16x64x64xF32_M1x2x128x128xF32_M16x2x3x3xF32_M16xF32_I32_I32_I32(memref<1x2x128x128xf32>, memref<16x2x3x3xf32>, memref<16xf32>, i32, i32, i32) -> memref<1x16x64x64xf32>
// ATEN:       }
module  {
  func @graph(%arg0: tensor<1x2x128x128xf32>, %arg1: tensor<16x2x3x3xf32>, %arg2: tensor<16xf32>) -> tensor<1x16x64x64xf32> {
    %c2_i64 = constant 2 : i64
    %c2_i64_0 = constant 2 : i64
    %0 = basicpy.build_list %c2_i64, %c2_i64_0 : (i64, i64) -> !basicpy.ListType
    %c1_i64 = constant 1 : i64
    %c1_i64_1 = constant 1 : i64
    %1 = basicpy.build_list %c1_i64, %c1_i64_1 : (i64, i64) -> !basicpy.ListType
    %c3_i64 = constant 3 : i64
    %c3_i64_2 = constant 3 : i64
    %2 = basicpy.build_list %c3_i64, %c3_i64_2 : (i64, i64) -> !basicpy.ListType
    %false = constant false
    %c0_i64 = constant 0 : i64
    %c0_i64_3 = constant 0 : i64
    %3 = basicpy.build_list %c0_i64, %c0_i64_3 : (i64, i64) -> !basicpy.ListType
    %c1_i64_4 = constant 1 : i64
    %false_5 = constant false
    %true = constant true
    %4 = "aten.convolution"(%arg0, %arg1, %arg2, %0, %1, %2, %false, %3, %c1_i64_4) : (tensor<1x2x128x128xf32>, tensor<16x2x3x3xf32>, tensor<16xf32>, !basicpy.ListType, !basicpy.ListType, !basicpy.ListType, i1, !basicpy.ListType, i64) -> tensor<1x16x64x64xf32>
    return %4 : tensor<1x16x64x64xf32>
  }
}